---
title: "Integrate and cluster T cells"
author: "Jovana Maksimovic and George Howitt"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
site: workflowr::wflow_site
output:
  bookdown::html_document2:
    base_format: workflowr::wflow_html
    toc: yes
    toc_float: yes
    theme: cosmo
    highlight: textmate
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Load libraries.

```{r}
suppressPackageStartupMessages({
 library(SingleCellExperiment)
 library(edgeR)
 library(tidyverse)
 library(ggplot2)
 library(Seurat)
 library(glmGamPoi)
 library(dittoSeq)
 library(here)
 library(clustree)
 library(patchwork)
 library(AnnotationDbi)
 library(org.Hs.eg.db)
 library(glue)
 library(speckle)
})
```

# Load data

Load T-cell subset Seurat object.

```{r}
seu <- readRDS(here("data",
              "C133_Neeland_full_clean_t_cells.SEU.rds"))
seu
```

# Data integration

Visualise batch effects.

```{r, message=FALSE, warning=FALSE}
seu <- ScaleData(seu) %>%
  FindVariableFeatures() %>%
  RunPCA(dims = 1:30, verbose = FALSE) %>%
  RunUMAP(dims = 1:30, verbose = FALSE)

DimPlot(seu, group.by = "Batch", reduction = "umap")
```

## Cell cycle scoring

Assign each cell a score, based on its expression of G2/M and S phase markers as described in the Seurat workflow [here](https://satijalab.org/seurat/articles/cell_cycle_vignette.html).

```{r, warning=FALSE}
s.genes <- cc.genes.updated.2019$s.genes
g2m.genes <- cc.genes.updated.2019$g2m.genes

seu <- CellCycleScoring(seu, s.features = s.genes, g2m.features = g2m.genes, 
                        set.ident = TRUE)
```

## Effect of cell cyle in data

PCA of cell cycle genes.

```{r}
DimPlot(seu, group.by = "Phase") -> p1

seu %>%
  RunPCA(features = c(s.genes, g2m.genes),
                      dims = 1:30, verbose = FALSE) %>%
  DimPlot(reduction = "pca") -> p2

(p1 | p2) + plot_layout(guides = "collect")
```

Visualize the distribution of cell cycle markers.

```{r}
# Visualize the distribution of cell cycle markers across
RidgePlot(seu, features = c("PCNA", "TOP2A", "MCM6", "MKI67"), ncol = 2)
```

Using the `Seurat` *Alternate Workflow* from the afore mentioned vignette, calculate the difference between the G2M and S phase scores so that signals separating non-cycling cells and cycling cells will be maintained, but differences in cell cycle phase among proliferating cells (which are often uninteresting), can be regressed out of the data.

```{r}
seu$CC.Difference <- seu$S.Score - seu$G2M.Score
```

## Integrate RNA data

Split by *batch* for integration. Normalise with `SCTransform`. Increase the strength of alignment by increasing `k.anchor` parameter to 20 as recommended in Seurat Fast integration with RPCA [vignette](https://satijalab.org/seurat/articles/integration_rpca.html).

First, integrate the RNA data.

```{r}
out <- here("data",
            "C133_Neeland_full_clean_integrated_t_cells.SEU.rds")

if(!file.exists(out)){
  DefaultAssay(seu) <- "RNA"
  VariableFeatures(seu) <- NULL
  seu[["pca"]] <- NULL
  seu[["umap"]] <- NULL
  
  seuLst <- SplitObject(seu, split.by = "Batch")
  rm(seu)
  gc()
  
  # normalise with SCTransform and regress out cell cycle score difference
  seuLst <- lapply(X = seuLst, FUN = SCTransform, method = "glmGamPoi",
                   vars.to.regress = "CC.Difference")
  # integrate RNA data
  features <- SelectIntegrationFeatures(object.list = seuLst,
                                        nfeatures = 3000)
  seuLst <- PrepSCTIntegration(object.list = seuLst, anchor.features = features)
  seuLst <- lapply(X = seuLst, FUN = RunPCA, features = features)
  anchors <- FindIntegrationAnchors(object.list = seuLst,
                                    normalization.method = "SCT",
                                    anchor.features = features,
                                    k.anchor = 20,
                                    dims = 1:30, reduction = "rpca")
  seu <- IntegrateData(anchorset = anchors, 
                       k.weight = min(100, min(sapply(seuLst, ncol)) - 5),
                       normalization.method = "SCT",
                       dims = 1:30)
  
  DefaultAssay(seu) <- "integrated"
  seu <- RunPCA(seu, dims = 1:30, verbose = FALSE) %>%
    RunUMAP(dims = 1:30, verbose = FALSE)

  saveRDS(seu, file = out)
  fs::file_chmod(out, "664")
  if(any(str_detect(fs::group_ids()$group_name, 
                    "oshlack_lab"))) fs::file_chown(out, 
                                                    group_id = "oshlack_lab")
  
} else {
  seu <- readRDS(file = out)
  
}
```


## Integrate ADT data

```{r}
out <- here("data",
            "C133_Neeland_full_clean_integrated_t_cells.ADT.SEU.rds")

if(!file.exists(out)){
  ## integrate ADT data
  DefaultAssay(seu) <- "ADTs"
  tmp <- DietSeurat(subset(seu, cells = which(seu$Batch !=0)), 
                       assays = "ADTs")
  DefaultAssay(tmp) <- "ADTs"
  seuLst <- SplitObject(tmp, split.by = "Batch")
  seuLst <- lapply(X = seuLst, FUN = function(x) {
    VariableFeatures(x) <- rownames(x)
    x <- NormalizeData(x, verbose = FALSE, normalization.method = "CLR",
                       margin = 2)
    x
  })
  features <- SelectIntegrationFeatures(object.list = seuLst)
  seuLst <- lapply(X = seuLst, FUN = function(x) {
    x <- ScaleData(x, features = features, verbose = FALSE)
    x <- RunPCA(x, features = features, verbose = FALSE)
    x
  })
  anchors <- FindIntegrationAnchors(object.list = seuLst, reduction = "rpca",
                                    dims = 1:30)
  tmp <- IntegrateData(anchorset = anchors, dims = 1:30)
  
  DefaultAssay(tmp) <- "integrated"
  tmp <- ScaleData(tmp) %>%
    RunPCA(dims = 1:30, verbose = FALSE) %>%
    RunUMAP(dims = 1:30, verbose = FALSE)

  # create combined object that only contains cells with RNA+ADT data
  seuADT <- subset(seu, cells = which(seu$Batch !=0))
  seuADT[["integrated.adt"]] <- tmp[["integrated"]]
  seuADT[["pca.adt"]] <- tmp[["pca"]]
  seuADT[["umap.adt"]] <- tmp[["umap"]]

  saveRDS(seuADT, file = out)
  fs::file_chmod(out, "664")
  if(any(str_detect(fs::group_ids()$group_name, 
                    "oshlack_lab"))) fs::file_chown(out, 
                                                    group_id = "oshlack_lab")
  
} else {
  seuADT <- readRDS(file = out)
  
}
```

Visualise the results.

```{r, fig.asp=1}
DefaultAssay(seuADT) <- "integrated"

DimPlot(seu, group.by = "Batch", reduction = "umap") -> p1
DimPlot(seuADT, group.by = "Batch", reduction = "umap") -> p2
DimPlot(seuADT, group.by = "Batch", reduction = "umap.adt") -> p3

(p1 / ((p2 | p3) +
  plot_layout(guides = "collect"))) &
  theme(axis.title = element_text(size = 8),
        axis.text = element_text(size = 8)) 
```

```{r, fig.asp=1}
DimPlot(seu, group.by = "Phase", reduction = "umap") -> p1
DimPlot(seuADT, group.by = "Phase", reduction = "umap") -> p2
DimPlot(seuADT, group.by = "Phase", reduction = "umap.adt") -> p3

(p1 / ((p2 | p3) +
  plot_layout(guides = "collect"))) &
  theme(axis.title = element_text(size = 8),
        axis.text = element_text(size = 8)) 
```


# Clustering 

Perform clustering only on data that has ADTs i.e. exclude batch 0.

## Dimensionality reduction RNA

```{r, fig.width=9, fig.height=27}
# remove HLA, immunoglobulin, RNA, MT, and RP genes from variable genes list
var_regex = '^HLA-|^IG[HJKL]|^RNA|^MT-|^RP' 
hvg <- grep(var_regex, VariableFeatures(seuADT), invert = TRUE, value = TRUE)
# assign edited variable gene list back to object 
VariableFeatures(seuADT) <- hvg

# redo PCA and UMAP 
seuADT <- RunPCA(seuADT, dims = 1:30, verbose = FALSE) %>%
    RunUMAP(dims = 1:30, verbose = FALSE)

DimHeatmap(seuADT, dims = 1:30, cells = 500, balanced = TRUE,
           reduction = "pca", assays = "integrated")
```

```{r}
ElbowPlot(seuADT, ndims = 30, reduction = "pca")
```

## Dimensionality reduction ADT

```{r, fig.width=9, fig.height=27}
DimHeatmap(seuADT, dims = 1:30, cells = 500, balanced = TRUE,
           reduction = "pca.adt", assays = "integrated.adt")
```

```{r}
ElbowPlot(seuADT, ndims = 30, reduction = "pca.adt")
```

Perform clustering at a range of resolutions and visualise to see which is appropriate to proceed with.

```{r, warning=FALSE, message=FALSE, fig.asp=1.25}
out <- here("data",
            "C133_Neeland_full_clean_integrated_clustered_t_cells.ADT.SEU.rds")

if(!file.exists(out)){
  DefaultAssay(seuADT) <- "integrated"
  seuADT <- FindMultiModalNeighbors(seuADT, reduction.list = list("pca", "pca.adt"), 
                                 dims.list = list(1:30, 1:10), 
                                 modality.weight.name = "RNA.weight")
  seuADT <- FindClusters(seuADT, algorithm = 3, 
                      resolution = seq(0.1, 1, by = 0.1),
                      graph.name = "wsnn")
  seuADT <- RunUMAP(seuADT, dims = 1:30, nn.name = "weighted.nn", 
                 reduction.name = "wnn.umap", reduction.key = "wnnUMAP_",
                 return.model = TRUE)
  saveRDS(seuADT, file = out)
  fs::file_chmod(out, "664")
  if(any(str_detect(fs::group_ids()$group_name, 
                    "oshlack_lab"))) fs::file_chown(out, 
                                                    group_id = "oshlack_lab")
  
} else {
  seuADT <- readRDS(file = out)
  
}

clustree::clustree(seuADT, prefix = "wsnn_res.")
```

```{r, fig.asp=1}
grp <- "wsnn_res.0.6"
# change factor ordering
seuADT@meta.data[,grp] <- fct_inseq(seuADT@meta.data[,grp])

DimPlot(seuADT, group.by = grp, label = T) + 
  theme(legend.position = "bottom")
```

```{r}
 VlnPlot(seuADT, features = "integrated.weight", group.by = grp, sort = TRUE, 
         pt.size = 0.1) +
  NoLegend()
```

## Map batch 0 samples to rest
### Find anchors

```{r}
reference <- seuADT
DefaultAssay(seu) <- "RNA"
query <- DietSeurat(subset(seu, cells = which(seu$Batch == 0)),
                    assays = "RNA")

DefaultAssay(reference) <- "integrated"

anchors <- FindTransferAnchors(
  reference = reference,
  query = query,
  normalization.method = "SCT",
  reference.reduction = "pca",
  dims = 1:50
)
```


### Project batch 0 samples onto reference UMAP

```{r}
query <- MapQuery(
  anchorset = anchors,
  query = query,
  reference = reference,
  refdata = list(
    wsnn = grp,
    ADT = "ADT"
  ),
  reference.reduction = "pca", 
  reduction.model = "wnn.umap"
)

query
```

### Visualise batch 0 samples on reference UMAP

```{r, fig.asp=1}
query$predicted.wsnn <- fct_inseq(query$predicted.wsnn)

DimPlot(query, reduction = "ref.umap", group.by = "predicted.wsnn", 
        label = TRUE, label.size = 3 ,repel = TRUE) + 
  theme(legend.position = "bottom")
```

### Azimuth prediction scores per cluster

```{r}
ggplot(query@meta.data, aes(x = predicted.wsnn, 
                            y = predicted.wsnn.score,
                            fill = predicted.wsnn)) +
  geom_boxplot() + NoLegend()
```

## Compute combined UMAP

```{r}
# merge reference (integrated + WNN clustered) and query (RNA only samples)
reference$id <- 'reference'
query$id <- 'query'
DefaultAssay(reference) <- "integrated"
refquery <- merge(DietSeurat(reference,
                             assays = c("RNA","ADT","integrated","SCT"),
                             dimreducs = c("pca")),
                  DietSeurat(query,
                             assays = c("RNA"),
                             dimreducs = "ref.pca"))
refquery[["pca"]] <- merge(reference[["pca"]], query[["ref.pca"]])
refquery <- RunUMAP(refquery, reduction = 'pca', dims = 1:50, assay = "integrated")
```

### Visualise overlay of batch0 (query) and rest of (reference) samples

```{r}
DimPlot(refquery, group.by = 'predicted.wsnn', reduction = "umap")
```
## Combined data

```{r}
# combine cluster annotations from reference and query
refquery@meta.data[, grp] <- ifelse(is.na(refquery@meta.data[,grp]),
                          refquery$predicted.wsnn,
                          refquery@meta.data[,grp])
# change factor ordering
refquery@meta.data[,grp] <- fct_inseq(refquery@meta.data[,grp])

DimPlot(refquery, reduction = "umap", group.by = grp, 
             label = TRUE, label.size = 3) + NoLegend() 
DimPlot(refquery, reduction = "umap", group.by = "Disease", 
             label = FALSE, label.size = 3)
DimPlot(refquery, reduction = "umap", group.by = "Phase", 
             label = FALSE, label.size = 3)
```

```{r}
out <- here("data",
            "C133_Neeland_full_clean_integrated_clustered_mapped_t_cells.ADT.SEU.rds")
if(!file.exists(out)){
  saveRDS(refquery, file = out)
}
```


## Examine clusters
### No. cells per cluster

```{r}
refquery@meta.data %>%
  ggplot(aes(x = !!sym(grp), fill = !!sym(grp))) +
  geom_bar() +
  geom_text(aes(label = ..count..), stat = "count",
            vjust = -0.5, colour = "black", size = 2) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  NoLegend()
```

### QC metrics per cluster
Visualise quality metrics by cluster.

```{r, fig.asp=0.8}
refquery@meta.data %>%
  ggplot(aes(x = !!sym(grp),
             y = nCount_RNA,
             fill = !!sym(grp))) +
  geom_violin(scale = "area") +
  scale_y_log10() +
  NoLegend() -> p2

refquery@meta.data %>%
  ggplot(aes(x = !!sym(grp),
             y = nFeature_RNA,
             fill = !!sym(grp))) +
  geom_violin(scale = "area") +
  scale_y_log10() +
  NoLegend() -> p3

(p2 / p3) & theme(text = element_text(size = 8))
```

### Batch compositions of clusters
Let's check the batch composition of each of the clusters.

```{r}
dittoBarPlot(refquery,
             var = "Batch", 
             group.by = grp)
```

### Sample compositions of clusters

```{r, fig.asp=1}
dittoBarPlot(refquery,
             var = "sample.id", 
             group.by = grp) + ggtitle("Samples") +
  theme(legend.position = "bottom")
```


# Marker gene analysis

Adapted from Dr. Belinda Phipson's [work](https://bphipson.github.io/Human_Development_snRNAseq/14-MarkerAnalysisBCT.html) for [@Sim2021-cg].

## Test for marker genes using *limma*

```{r}
# limma-trend for DE
Idents(refquery) <- grp

logcounts <- normCounts(DGEList(as.matrix(refquery[["RNA"]]@counts)),
                        log = TRUE, prior.count = 0.5)
entrez <- AnnotationDbi::mapIds(org.Hs.eg.db,
                                keys = rownames(logcounts),
                                column = c("ENTREZID"),
                                keytype = "SYMBOL",
                                multiVals = "first")
# remove genes without entrez IDs
logcounts <- logcounts[!is.na(entrez),]
# remove confounding genes from marker gene list
logcounts <- logcounts[!str_detect(rownames(logcounts), var_regex),]

maxclust <- length(levels(Idents(refquery))) - 1

clustgrp <- paste0("c", Idents(refquery))
clustgrp <- factor(clustgrp, levels = paste0("c", 0:maxclust))
donor <- seu$sample.id

design <- model.matrix(~ 0 + clustgrp + donor)
colnames(design)[1:(length(levels(clustgrp)))] <- levels(clustgrp)

# Create contrast matrix
mycont <- matrix(NA, ncol = length(levels(clustgrp)),
                 nrow = length(levels(clustgrp)))
rownames(mycont) <- colnames(mycont) <- levels(clustgrp)
diag(mycont) <- 1
mycont[upper.tri(mycont)] <- -1/(length(levels(factor(clustgrp))) - 1)
mycont[lower.tri(mycont)] <- -1/(length(levels(factor(clustgrp))) - 1)

# Fill out remaining rows with 0s
zero.rows <- matrix(0, ncol = length(levels(clustgrp)),
                    nrow = (ncol(design) - length(levels(clustgrp))))
fullcont <- rbind(mycont, zero.rows)
rownames(fullcont) <- colnames(design)

fit <- lmFit(logcounts, design)

fit.cont <- contrasts.fit(fit, contrasts = fullcont)
fit.cont <- eBayes(fit.cont, trend = TRUE, robust = TRUE)

summary(decideTests(fit.cont))
```

## Test relative to a threshold (TREAT)

```{r}
tr <- treat(fit.cont, lfc = 0.25)
dt <- decideTests(tr)
summary(dt)
```

### Mean-difference plots per cluster

```{r, fig.asp=1}
par(mfrow=c(4,3))
par(mar=c(2,3,1,2))

for(i in 1:ncol(mycont)){
  plotMD(tr, coef = i, status = dt[,i], hl.cex = 0.5)
  abline(h = 0, col = "lightgrey")
  lines(lowess(tr$Amean, tr$coefficients[,i]), lwd = 1.5, col = 4)
}
```

### *limma* marker gene dotplot

```{r, fig.asp=2.25}
sig.genes <- vector("list", ncol(tr))
p <- vector("list",length(sig.genes))
DefaultAssay(refquery) <- "RNA"

for(i in 1:length(sig.genes)){
  top <- topTreat(tr, coef = i, n = Inf)
  sig.genes[[i]] <- rownames(top)[top$logFC > 0][1:10]
}

sig <- unlist(sig.genes)
geneCols <- c(rep(rep(c("grey","black"), each = 10), ncol(tr)/2),
              rep("grey", 10))[!duplicated(sig)]
sig <- sig[!duplicated(sig)]

pal <- paletteer::paletteer_d("vapoRwave::cool")
DotPlot(refquery,    
        features = sig,
        group.by = grp,
        cols = c("lightgrey", "red"),
        dot.scale = 3, assay = "SCT") +
    RotatedAxis() +
    FontSize(y.text = 8, x.text = 12) +
    labs(y = element_blank(), x = element_blank()) +
    coord_flip() +
  theme(axis.text.y = element_text(color = geneCols)) +
  ggtitle("Top 10 cluster marker genes without duplicates")+
  scale_color_gradient2(low = pal[1],
                        mid = pal[3],
                        high = pal[5])
```

### Export marker genes per cluster

The Broad MSigDB Reactome pathways are tested for each contrast using `cameraPR` from *limma*. The `cameraPR` method tests whether a set of genes is highly ranked relative to other genes in terms of differential expression, accounting for inter-gene correlation.

Prepare gene sets of interest.

```{r}
if(!file.exists(here("data/Hs.c2.cp.reactome.v7.1.entrez.rds")))
  download.file("https://bioinf.wehi.edu.au/MSigDB/v7.1/Hs.c2.cp.reactome.v7.1.entrez.rds",
                here("data/Hs.c2.cp.reactome.v7.1.entrez.rds"))
Hs.c2.reactome <- readRDS(here("data/Hs.c2.cp.reactome.v7.1.entrez.rds"))

gns <- AnnotationDbi::mapIds(org.Hs.eg.db, 
                             keys = rownames(tr), 
                             column = c("ENTREZID"),
                             keytype = "SYMBOL",
                             multiVals = "first")
```

```{r}
options(scipen=-1, digits = 6)
contnames <- colnames(mycont)
dirName <- here("output",
                "cluster_markers",
                "t_cells")

if(!dir.exists(dirName)) dir.create(dirName, recursive = TRUE)

for(c in colnames(tr)){
  top <- topTreat(tr, coef = c, n = Inf)
  top <- top[top$logFC > 0, ]

  write.csv(top[1:100, ] %>%
              rownames_to_column(var = "Symbol"),
            file = glue("{dirName}/up-cluster-limma-{c}.csv"),
            sep = ",",
            quote = FALSE,
            col.names = NA,
            row.names = TRUE)

  # gene set testing results
  c2.id <- ids2indices(Hs.c2.reactome, unname(gns[rownames(tr)]))

  cameraPR(tr$t[,glue("{c}")], c2.id) %>%
    rownames_to_column(var = "Pathway") %>%
    dplyr::filter(Direction == "Up") %>%
    slice_head(n = 50) %>%
    write.csv(file = here(glue("{dirName}/REACTOME-cluster-limma-{c}.csv")),
            sep = ",",
            quote = FALSE,
            col.names = NA,
            row.names = TRUE)
}
```


# ADT marker analysis
## DSB normalisation

ADT data processing. Use DSB for normalization.

```{r}
library(dsb)
```

Define isotype controls.
```{r}
read_csv(file = here("data",
                     "C133_Neeland_batch1",
                     "data",
                     "sample_sheets",
                     "ADT_features.csv")) %>%
  dplyr::filter(grepl("[Ii]sotype", name)) %>%
  pull(id) -> isotype.controls 

isotype.controls
```

```{r}
out <- here("data/RDS/C133_Neeland_T_cells.DSB.SEU.rds")

if(!file.exists(out)){
norm.adt <- ModelNegativeADTnorm(cell_protein_matrix = seuADT[["ADT"]]@counts,
                                      denoise.counts = T,
                                      use.isotype.control = T, 
                                      isotype.control.name.vec = isotype.controls)
  saveRDS(norm.adt, file = out)
  fs::file_chmod(out, "664")
  fs::file_chown(out, group_id = "oshlack_lab")
  
} else {
  norm.adt <- readRDS(file = out)
  
}
```

```{r}
prots_all <- read.csv(file = here("data",
                     "C133_Neeland_batch1",
                     "data",
                     "sample_sheets",
                     "ADT_features.csv")) 

head(prots_all) %>% knitr::kable()
```

```{r}
prots_of_interest <- read.csv(file = here("data",
                              "TotalSeq_A_Proteins_of_Interest.csv"),
                              header = T)

head(prots_of_interest) %>% knitr::kable()
```

<!-- Load the DSB normalised ADT data. -->

<!-- ```{r} -->
<!-- adtCtrl <- readRDS(file = here("data/RDS/C133_Neeland_control_only_T_cells.DSB.SEU.rds")) -->
<!-- adtCF <- readRDS(file = here("data/RDS/C133_Neeland_CF_only_T_cells.DSB.SEU.rds")) -->
<!-- adt <- cbind(adtCF, adtCtrl) -->
<!-- adt <- adt[,match(colnames(seuADT),colnames(adt))] -->
<!-- all(colnames(adt) == colnames(seuADT)) -->
<!-- ``` -->

## Prepare ADT data
Clean up ADT names.

```{r}
# Regular expression pattern to remove the substrings
pattern <- "anti-human/mouse |anti-human/mouse/rat |anti-mouse/human "

# Remove the substrings using gsub()
prots_all$name <- gsub(pattern, "", prots_all$name)
all(rownames(norm.adt) == prots_all$id)
rownames(norm.adt) <- prots_all$name
```

## Find all marker ADTs using *Seurat*

```{r}
DefaultAssay(seuADT) <- "ADT"
Idents(seuADT) <- grp
seuADT@assays$ADT@data <- norm.adt

markers <- FindAllMarkers(seuADT, only.pos = TRUE, assay = "ADT",
                          features = rownames(seuADT)[!str_detect(rownames(seuADT), "[Ii]sotype")])

head(markers) %>% knitr::kable()
```

### Export *Seurat* marker ADTs per cluster

```{r}
options(scipen=-1, digits = 6)
contnames <- colnames(mycont)
dirName <- here("output/marker_analysis_seurat_integration/T_cells_ADTs")
if(!dir.exists(dirName)) dir.create(dirName, recursive = TRUE)

for(i in levels(markers$cluster)){
  top <- markers[markers$cluster == i,]
  
  write.csv(top, file = glue("{dirName}/up-cluster-seurat-c{i}.csv"))
}
```

### *Seurat* ADT marker heatmap 
Make data frame of proteins, clusters, expression levels.

```{r}
cbind(seuADT@meta.data %>%
        dplyr::select(!!sym(grp)),
      as.data.frame(t(seuADT@assays$ADT@data))) %>%
  pivot_longer(c(-!!sym(grp)), 
               names_to = "ADT",
               values_to = "expression") %>%
  dplyr::group_by(!!sym(grp), ADT) %>%
  dplyr::summarize(Expression = mean(expression)) %>%
  ungroup() -> dat

head(dat) %>% knitr::kable()
```

Look at overall expression of the DSB counts.

```{r}
plot(density(dat$Expression))
```

<!-- Make heatmap of top ADT markers per cluster; we take up to the top 10 ADTs at FDR < 0.01.   -->

<!-- ```{r} -->
<!-- contnames <- colnames(mycont) -->
<!-- top_markers <- NULL -->
<!-- for (i in 1:length(contnames)){ -->
<!--   top <- topTable(fit.cont, coef = i, p.value = 0.01) -->
<!--   #top <- topTreat(tr, coef = i, p.value = 0.01) -->
<!--   #Filter proteins of interest only -->
<!--   #top <- top[rownames(top) %in% prots_of_interest$Description,] -->
<!--   top <- top[top$logFC > 0,] -->
<!--   top_markers <- c(top_markers, rownames(top)[1:10]) -->
<!-- } -->
<!-- top_markers <- unique(top_markers) -->
<!-- ``` -->

Plot only top ADT markers for each cluster.

```{r}
dat2 <- dat %>%
  dplyr::filter(ADT %in% markers$gene)
```

```{r, fig.asp=0.8, fig.width=8}
library(tidyHeatmap)
dat2 |>
  heatmap(
    .column = !!sym(grp),
    .row = ADT,
    .value = Expression,
    scale = "none",
    rect_gp = grid::gpar(col = "white", lwd = 1),
    show_row_names = TRUE,
    column_names_gp = grid::gpar(fontsize = 10),
    column_title_gp = grid::gpar(fontsize = 12),
    row_names_gp = grid::gpar(fontsize = 8),
    row_title_gp = grid::gpar(fontsize = 12),
    column_title_side = "top",
    palette_value = circlize::colorRamp2(seq(-0.5, 1.7, length.out = 256),
                                          viridis::magma(256)),
    heatmap_legend_param = list(direction = "vertical")) 
```

## Find all marker ADTs using *limma*

Running the *limma* analysis on the DSB normalised counts.

```{r}
# limma-trend for DE
Idents(seuADT) <- grp

logcounts <- seuADT[["ADT"]]@data
maxclust <- length(levels(Idents(seuADT))) - 1

clustgrp <- paste0("c", Idents(seuADT))
clustgrp <- factor(clustgrp, levels = paste0("c", 0:maxclust))
donor <- seuADT$sample.id

design <- model.matrix(~ 0 + clustgrp + donor)
colnames(design)[1:(length(levels(clustgrp)))] <- levels(clustgrp)

# Create contrast matrix
mycont <- matrix(NA, ncol = length(levels(clustgrp)),
                 nrow = length(levels(clustgrp)))
rownames(mycont) <- colnames(mycont) <- levels(clustgrp)
diag(mycont) <- 1
mycont[upper.tri(mycont)] <- -1/(length(levels(factor(clustgrp))) - 1)
mycont[lower.tri(mycont)] <- -1/(length(levels(factor(clustgrp))) - 1)

# Fill out remaining rows with 0s
zero.rows <- matrix(0, ncol = length(levels(clustgrp)),
                    nrow = (ncol(design) - length(levels(clustgrp))))
fullcont <- rbind(mycont, zero.rows)
rownames(fullcont) <- colnames(design)

fit <- lmFit(logcounts, design)
fit.cont <- contrasts.fit(fit, contrasts = fullcont)
fit.cont <- eBayes(fit.cont, trend = TRUE, robust = TRUE)

summary(decideTests(fit.cont, p.value = 0.01))
```
### Test relative to a threshold (TREAT)

```{r}
tr <- treat(fit.cont, lfc = 0.25)
dt <- decideTests(tr)
summary(dt)
```

<!-- ## ADT heatmap (most significant) -->
<!-- Make data frame of proteins, clusters, expression levels -->

<!-- ```{r} -->
<!-- cbind(seuADT@meta.data %>% -->
<!--         dplyr::select(!!sym(grp)), -->
<!--       as.data.frame(t(seuADT@assays$ADT@counts))) %>% -->
<!--   pivot_longer(c(-!!sym(grp)),  -->
<!--                names_to = "ADT", -->
<!--                values_to = "expression") %>% -->
<!--   dplyr::group_by(!!sym(grp), ADT) %>% -->
<!--   dplyr::summarize(Expression = mean(expression)) %>% -->
<!--   ungroup() -> dat -->

<!-- head(dat) %>% knitr::kable() -->
<!-- ``` -->

<!-- Look at overall expression of the DSB counts -->
<!-- ```{r} -->
<!-- plot(density(dat$Expression)) -->
<!-- ``` -->

### *limma* ADT marker heatmap 

Make heatmap of top ADT markers per cluster; we take up to the top 10 ADTs at FDR < 0.01.

```{r}
contnames <- colnames(mycont)
top_markers <- NULL
for (i in 1:length(contnames)){
  #top <- topTable(fit.cont, coef = i, p.value = 0.01)
  top <- topTreat(tr, coef = i, p.value = 0.01)
  top <- top[top$logFC > 0,]
  top_markers <- c(top_markers, rownames(top)[1:10])
}
top_markers <- unique(top_markers)
```

```{r}
dat2 <- dat %>%
  dplyr::filter(ADT %in% top_markers)
```

```{r, fig.asp=1.25, fig.width=8}
dat2 |>
  heatmap(
    .column = !!sym(grp),
    .row = ADT,
    .value = Expression,
    scale = "none",
    rect_gp = grid::gpar(col = "white", lwd = 1),
    show_row_names = TRUE,
    column_names_gp = grid::gpar(fontsize = 10),
    column_title_gp = grid::gpar(fontsize = 12),
    row_names_gp = grid::gpar(fontsize = 8),
    row_title_gp = grid::gpar(fontsize = 12),
    column_title_side = "top",
    palette_value = circlize::colorRamp2(seq(-0.5, 1.7, length.out = 256),
                                          viridis::magma(256)),
    heatmap_legend_param = list(direction = "vertical"))
```

### Export *limma* marker ADTs per cluster

```{r}
options(scipen=-1, digits = 6)
contnames <- colnames(mycont)
dirName <- here("output/marker_analysis_seurat_integration/T_cells_ADTs")
if(!dir.exists(dirName)) dir.create(dirName, recursive = TRUE)

for(i in levels(markers$cluster)){
  
  top <- topTreat(tr, coef = glue("c{i}"), n = Inf)
  top <- top[top$logFC > 0, ]

  write.csv(top,
            file = glue("{dirName}/up-cluster-limma-c{i}.csv"))
}
```

<!-- ## ADT heatmap (significant proteins of interest) -->
<!-- Make heatmap of top ADT markers per cluster; we take up to the top 10 ADTs at FDR < 0.01.   -->

<!-- ```{r} -->
<!-- contnames <- colnames(mycont) -->
<!-- top_markers <- NULL -->
<!-- for (i in 1:length(contnames)){ -->
<!--   top <- topTreat(tr, coef = i, p.value = 0.01) -->
<!--   #top <- topTable(fit.cont, coef = i, number = Inf) -->
<!--   #Filter proteins of interest only -->
<!--   top <- top[rownames(top) %in% prots_of_interest$Description,] -->
<!--   top <- top[top$logFC > 0,] -->
<!--   top_markers <- c(top_markers, rownames(top)[1:10]) -->
<!-- } -->
<!-- top_markers <- unique(top_markers) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- dat2 <- dat %>% -->
<!--   dplyr::filter(ADT %in% top_markers) -->
<!-- ``` -->

<!-- ```{r, fig.asp=1.5, fig.width=8} -->
<!-- dat2 |> -->
<!--   heatmap( -->
<!--     .column = Cluster, -->
<!--     .row = ADT, -->
<!--     .value = `ADT Exp.`, -->
<!--     scale = "none", -->
<!--     rect_gp = grid::gpar(col = "white", lwd = 1), -->
<!--     show_row_names = TRUE, -->
<!--     column_names_gp = grid::gpar(fontsize = 10), -->
<!--     column_title_gp = grid::gpar(fontsize = 12), -->
<!--     row_names_gp = grid::gpar(fontsize = 8), -->
<!--     row_title_gp = grid::gpar(fontsize = 12), -->
<!--     column_title_side = "top", -->
<!--     palette_value = circlize::colorRamp2(seq(-1, 2, length.out = 256), -->
<!--                                           viridis::magma(256)), -->
<!--     heatmap_legend_param = list(direction = "vertical"))  -->
<!-- ``` -->


# Session info {.appendix}










