---
title: "Inflammation of Paediatric Pulmonary Diseases"
subtitle: "DGE analysis of CF status in B cells"
author: "Jovana Maksimovic"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
site: workflowr::wflow_site
output:
  bookdown::html_document2:
    base_format: workflowr::wflow_html
    toc: yes
    toc_float: yes
    theme: cosmo
    highlight: textmate
    number_sections: true
---

```{r, echo = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

# Load libraries

```{r, message=FALSE, warning=FALSE}
suppressPackageStartupMessages({
  library(BiocStyle)
  library(tidyverse)
  library(here)
  library(glue)
  library(Seurat)
  library(patchwork)
  library(paletteer)
  library(limma)
  library(edgeR)
  library(RUVSeq)
  library(scMerge)
  library(SingleCellExperiment)
  library(scater)
  library(tidyHeatmap)
  library(org.Hs.eg.db)
  library(TxDb.Hsapiens.UCSC.hg38.knownGene)
  library(missMethyl)
  library(ComplexHeatmap)
})

source(here("code/utility.R"))
```


# Load Data

```{r}
ambient <- "_decontx"
file <- here("data",
            "C133_Neeland_merged",
            glue("C133_Neeland_full_clean{ambient}_other_cells_annotated_diet.SEU.rds"))

seu <- readRDS(file)
seu
```


# Prepare data

## Create pseudobulk samples

Use *cell type* and *sample* as our two factors; each column of the output
corresponds to one unique combination of these two factors. 

```{r}
# select the cell type for pseudobulks
cell <- "DC cells"

out <- here("data",
            "C133_Neeland_merged",
            glue("C133_Neeland_full_clean{ambient}_{cell}_pseudobulk.rds"))

sce <- SingleCellExperiment(list(counts = seu[["RNA"]]@counts),
                            colData = seu@meta.data)
sce <- sce[, sce$ann_level_1 %in% cell]

if(!file.exists(out)){
  pseudoBulk <- aggregateAcrossCells(sce, 
                                 id = colData(sce)[, "sample.id"])
  saveRDS(pseudoBulk, file = out)
  
} else {
  pseudoBulk <- readRDS(file = out)
  
}

pseudoBulk
```

## Code micro information

Create a factor that identifies individuals that were infected with the top 4 clinically important pathogens at time of sample collection i.e. *Pseudomonas aeruginosa*, *Staphylococcus aureus*, *Haemophilus influenzae*, and *Aspergillus*.

```{r}
important_micro <- c("Pseudomonas aeruginosa", "Staphylococcus aureus",
                     "Haemophilus influenzae", "Aspergillus", "S. aureus",
                     "Staph Aureus (Methicillin Resistant)", "MRSA")

pseudoBulk$Micro_code <- sapply(strsplit(pseudoBulk$Bacteria_type, ","), function(bacteria){
  any(tolower(str_trim(bacteria)) %in% tolower(important_micro))
})

table(pseudoBulk$Micro_code)
```


## Filter samples

Make a `DGElist` object from pseudobulk data.

```{r}
yPB <- DGEList(counts = counts(pseudoBulk),
               samples = colData(pseudoBulk) %>% data.frame)
dim(yPB)
```

Remove genes with zero counts in all samples.

```{r}
keep <- rowSums(yPB$counts) > 0 
yFlt <- yPB[keep, ]
dim(yFlt)
```

Identify any samples that have too few cells for downstream statistical analysis. Examine number of cells per sample. Identify outliers and cross-reference with MDS plot. Determine a threshold for minimum number of cells per sample.

```{r, fig.width=9}
 yFlt$samples %>%
  data.frame %>%
  arrange(Group) %>%
  ggplot(aes(x = fct_inorder(sample.id), 
             y = ncells, fill = Group)) +
  geom_col() + 
  scale_fill_brewer(palette = "Set2") +
  scale_y_log10() +
  labs(x = "Sample",
       y = "Log10 No. cells") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5,
                                   size = 8),
        legend.position = "bottom") +
  geom_hline(yintercept = 500, linetype = "dashed") +
  geom_hline(yintercept = 100, linetype = "dotted") +
  geom_hline(yintercept = 50, linetype = "dashed") +
  geom_hline(yintercept = 25, linetype = "dotted") +
  geom_hline(yintercept = 10, linetype = "dashed")
```

Examine MDS plot for outlier samples.

```{r, fig.asp=1}
mds_by_factor <- function(data, factor, lab){
  dims <- list(c(1,2), c(2:3), c(3,4), c(4,5))
  p <- vector("list", length(dims))
  
  for(i in 1:length(dims)){
    
    mds <- limma::plotMDS(edgeR::cpm(data, 
                                     log = TRUE), 
                          gene.selection = "common",
                          plot = FALSE, dim.plot = dims[[i]])
    
    data.frame(x = mds$x, 
               y = mds$y,
               sample = rownames(mds$distance.matrix.squared)) %>%
      left_join(rownames_to_column(data$samples, var = "sample")) -> dat
    
    p[[i]] <- ggplot(dat, aes(x = x, y = y, 
                              colour = eval(parse(text=(factor))))) +
      geom_point(size = 3) +
      ggrepel::geom_text_repel(aes(label = sample.id),
                               size = 2) +
      labs(x = glue("Principal Component {dims[[i]][1]}"),
           y = glue("Principal Component {dims[[i]][2]}"),
           colour = lab) +
      theme(legend.direction = "horizontal",
            legend.text = element_text(size = 8),
            legend.title = element_text(size = 9),
            axis.text = element_text(size = 8),
            axis.title = element_text(size = 9)) -> p[[i]]
  }
  
  wrap_plots(p, ncol = 2) + 
    plot_layout(guides = "collect") &
    theme(legend.position = "bottom")
}

mds_by_factor(yFlt, "as.factor(Batch)", "Batch") & scale_color_brewer(palette = "Set1")
mds_by_factor(yFlt, "as.factor(Sex)", "Sex") & scale_color_brewer(palette = "Set2")
mds_by_factor(yFlt, "log2(Age)", "Log2 Age") & scale_colour_viridis_c(option = "magma")
mds_by_factor(yFlt, "log2(ncells)", "Log2 ncells") & scale_colour_viridis_c(option = "magma") 
mds_by_factor(yFlt, "as.factor(Group)", "Group") & scale_color_brewer(palette = "Dark2")
mds_by_factor(yFlt, "as.factor(Severity)", "Severity") & scale_color_brewer(palette = "Accent")
mds_by_factor(yFlt, "as.factor(Micro_code)", "Infection") & scale_color_brewer(palette = "Pastel1")
```

Filter out samples with less than previously determined minimum number of cells.

```{r}
minCells <- 25 
yFlt <- yFlt[, yFlt$samples$ncells > minCells]
dim(yFlt)
```

Re-examine MDS plots.

```{r, fig.asp=1}
mds_by_factor(yFlt, "as.factor(Batch)", "Batch") & scale_color_brewer(palette = "Set1")
mds_by_factor(yFlt, "as.factor(Sex)", "Sex") & scale_color_brewer(palette = "Set2")
mds_by_factor(yFlt, "log2(Age)", "Log2 Age") & scale_colour_viridis_c(option = "magma") 
mds_by_factor(yFlt, "log2(ncells)", "Log2 ncells") & scale_colour_viridis_c(option = "magma") 
mds_by_factor(yFlt, "as.factor(Group)", "Group") & scale_color_brewer(palette = "Dark2")
mds_by_factor(yFlt, "as.factor(Severity)", "Severity") & scale_color_brewer(palette = "Accent")
mds_by_factor(yFlt, "as.factor(Micro_code)", "Infection") & scale_color_brewer(palette = "Pastel1")
```


# Analyse data subsets

## CF vs. non-CF controls

### Prepare data

#### Filter genes

Filter out genes with no ENTREZ IDs and very low median expression.

```{r}
gns <- AnnotationDbi::mapIds(org.Hs.eg.db,
                             keys = rownames(yFlt),
                             column = c("ENTREZID"),
                             keytype = "SYMBOL",
                             multiVals = "first")
keep <- !is.na(gns)
ySub <- yFlt[keep,]

thresh <- 2.75
m <- rowMedians(edgeR::cpm(ySub$counts, log = TRUE))
plot(density(m))
abline(v = thresh, lty = 2)
```

```{r}
# filter out genes with low median expression
keep <- m > thresh
table(keep)
ySub <- ySub[keep, ]
dim(ySub)
```

#### Examine covariates

Principal components analysis (PCA) allows us to mathematically determine the sources of variation in the data. We can then investigate whether these correlate with any of the specifed covariates.

Prepare the data.

```{r}
PCs <- prcomp(t(edgeR::cpm(ySub$counts, log = TRUE)), 
              center = TRUE, retx = TRUE)
loadings = PCs$x # pc loadings


nGenes = nrow(ySub)
nSamples = ncol(ySub)

datTraits <- ySub$samples %>% dplyr::select(Batch, Disease, Micro_code,
                                            Severity, Age, Sex, ncells) %>%
  mutate(Batch = factor(Batch),
         Disease = factor(Disease, 
                            labels = 1:length(unique(Disease))),
         Sex = factor(Sex, labels = length(unique(Sex))),
         Severity = factor(Severity, labels = length(unique(Severity)))) %>%
  mutate(across(everything(), as.numeric))

moduleTraitCor <- suppressWarnings(cor(loadings[, 1:min(10, nSamples)], 
                                       datTraits, use = "p"))
moduleTraitPvalue <- WGCNA::corPvalueStudent(moduleTraitCor, (nSamples-2))

textMatrix <- paste(signif(moduleTraitCor, 2), "\n(", 
                    signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) <- dim(moduleTraitCor)
```

Output results.

```{r, fig.asp=1.3}
par(mfrow = c(2, 1))
plot(PCs, type="lines", main = cell) # scree plot

## Display the correlation values within a heatmap plot
par(cex=0.75, mar = c(3, 5, 2, 1))
WGCNA::labeledHeatmap(Matrix = t(moduleTraitCor),
                            xLabels = colnames(loadings)[1:min(10, nSamples)],
                            yLabels = names(datTraits),
                            colorLabels = FALSE,
                            colors = WGCNA::blueWhiteRed(6),
                            textMatrix = t(textMatrix),
                            setStdMargins = FALSE,
                            cex.text = 1,
                            zlim = c(-1,1),
                            main = paste0("PCA-trait relationships: Top ", 
                                          min(10, nSamples), 
                                          " PCs"))
```

### `RUVseq` analysis

#### Select negative control genes

Use house-keeping genes (HKG) identified from human single-cell RNAseq experiments.

```{r}
data("segList", package = "scMerge")

HKGs <- segList$human$bulkRNAseqHK
ctl <- rownames(ySub) %in% HKGs
table(ctl)
```

Plot HKG expression profiles across all the samples.

```{r, fig.asp=1.5, fig.width=10}
edgeR::cpm(ySub$counts, log = TRUE) %>% 
  data.frame %>%
  rownames_to_column(var = "gene") %>%
  pivot_longer(-gene, names_to = "sample") %>%
  left_join(rownames_to_column(ySub$samples, 
                               var = "sample")) %>%
  dplyr::filter(gene %in% HKGs) %>%
  mutate(Batch = as.factor(Batch)) -> dat

dat %>%
  heatmap(gene, sample, value,
          scale = "row",
          show_row_names = FALSE,
          show_column_names = FALSE) %>%
  add_tile(Group) %>%
  add_tile(Severity) %>%
  add_tile(Batch) %>%
  add_tile(Participant) %>%
  add_tile(Age) %>%
  add_tile(Sex)
```

MDS plots based only on variablity captured by HKGs.

```{r, fig.asp=1}
mds_by_factor(ySub[rownames(ySub) %in% HKGs,], "as.factor(Batch)", "Batch") & scale_color_brewer(palette = "Set1")
mds_by_factor(ySub[rownames(ySub) %in% HKGs,], "as.factor(Sex)", "Sex") & scale_color_brewer(palette = "Set2")
mds_by_factor(ySub[rownames(ySub) %in% HKGs,], "log2(Age)", "Log2 Age") & scale_colour_viridis_c(option = "magma") 
mds_by_factor(ySub[rownames(ySub) %in% HKGs,], "log2(ncells)", "Log2 ncells") & scale_colour_viridis_c(option = "magma")
mds_by_factor(ySub[rownames(ySub) %in% HKGs,], "as.factor(Group)", "Group") & scale_color_brewer(palette = "Dark2")
mds_by_factor(ySub[rownames(ySub) %in% HKGs,], "as.factor(Severity)", "Severity") & 
  scale_color_brewer(palette = "Accent")
mds_by_factor(ySub[rownames(ySub) %in% HKGs,], "as.factor(Micro_code)", "Infection") & scale_color_brewer(palette = "Pastel1")
```

Investigate whether HKG PCAs correlate with any known covariates.
Prepare the data.

```{r}
PCs <- prcomp(t(edgeR::cpm(ySub$counts[ctl, ], log = TRUE)), 
              center = TRUE, retx = TRUE)
loadings = PCs$x # pc loadings


nGenes = nrow(ySub)
nSamples = ncol(ySub)

datTraits <- ySub$samples %>% dplyr::select(Batch, Disease, 
                                            Severity, Age, Sex, ncells, Micro_code) %>%
  mutate(Batch = factor(Batch),
         Disease = factor(Disease, 
                            labels = 1:length(unique(Disease))),
         Sex = factor(Sex, labels = length(unique(Sex))),
         Severity = factor(Severity, labels = length(unique(Severity)))) %>%
  mutate(across(everything(), as.numeric))

moduleTraitCor <- suppressWarnings(cor(loadings[, 1:min(10, nSamples)], 
                                       datTraits, use = "p"))
moduleTraitPvalue <- WGCNA::corPvalueStudent(moduleTraitCor, (nSamples-2))

textMatrix <- paste(signif(moduleTraitCor, 2), "\n(", 
                    signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) <- dim(moduleTraitCor)
```

Output results.

```{r, fig.asp=1.3}
par(mfrow = c(2, 1))
plot(PCs, type="lines", main = cell) # scree plot

## Display the correlation values within a heatmap plot
par(cex=0.75, mar = c(3, 5, 2, 1))
WGCNA::labeledHeatmap(Matrix = t(moduleTraitCor),
                            xLabels = colnames(loadings)[1:min(10, nSamples)],
                            yLabels = names(datTraits),
                            colorLabels = FALSE,
                            colors = WGCNA::blueWhiteRed(6),
                            textMatrix = t(textMatrix),
                            setStdMargins = FALSE,
                            cex.text = 1,
                            zlim = c(-1,1),
                            main = paste0("PCA-trait relationships: Top ", 
                                          min(10, nSamples), 
                                          " PCs"))
```

#### Select `k` value

First, we need to select `k` for use with `RUVseq`.
Examine the structure of the raw pseudobulk data.

```{r, fig.asp=0.4}
x1 <- as.factor(ySub$samples$Batch)
cols1 <- RColorBrewer::brewer.pal(7, "Set2")

par(mfrow = c(1,3))
EDASeq::plotRLE(edgeR::cpm(ySub$counts), 
                col = cols1[x1], ylim = c(-0.5, 0.5),
                main = "Raw RLE by batch", las = 2)
EDASeq::plotPCA(edgeR::cpm(ySub$counts), 
                col = cols1[x1], labels = FALSE,
                pch = 19, main = "Raw PCA by batch")
x2 <- as.factor(ySub$samples$Group)
cols2 <- RColorBrewer::brewer.pal(4, "Set1")
EDASeq::plotPCA(edgeR::cpm(ySub$counts), 
                col = cols2[x2], labels = FALSE,
                pch = 19, main = "Raw PCA by disease")
```


Select the value for the `k` parameter i.e. the number of columns of the `W` matrix that will be included in the modelling based on RLE and PCA plots and p-value histograms.

```{r, fig.asp=0.8}
# define the sample groups
group <- factor(ySub$samples$Group_severity)
sex <- factor(ySub$samples$Sex)
age <- log2(ySub$samples$Age)

for(k in 1:10){
  adj <- RUVg(ySub$counts, ctl, k = k)
  W <- adj$W
  
  # create the design matrix
  design <- model.matrix(~0 + group + W + sex + age)
  colnames(design)[1:length(levels(group))] <- levels(group)
  
  # add the factors for the replicate samples
  dups <- unique(ySub$samples$Participant[duplicated(ySub$samples$Participant)])
  dups <- sapply(dups, function(d){
    ifelse(ySub$samples$Participant == d, 1, 0)  
  }, USE.NAMES = TRUE)
  
  contr <- makeContrasts(CF.NO_MODvNON_CF.CTRL = 0.5*(CF.NO_MOD.M + CF.NO_MOD.S) - NON_CF.CTRL,
                         CF.IVAvNON_CF.CTRL = 0.5*(CF.IVA.M + CF.IVA.S) - NON_CF.CTRL,
                         CF.LUMA_IVAvNON_CF.CTRL = 0.5*(CF.LUMA_IVA.M + CF.LUMA_IVA.S) - NON_CF.CTRL,
                         levels = design)
    
  y <- DGEList(counts = ySub$counts)
  y <- calcNormFactors(y)
  y <- estimateGLMCommonDisp(y, design)
  y <- estimateGLMTagwiseDisp(y, design)
  fit <- glmFit(y, design)
  
  x1 <- as.factor(ySub$samples$Batch)
  cols1 <- RColorBrewer::brewer.pal(7, "Set2")
  
  par(mfrow = c(2,3))
  EDASeq::plotRLE(edgeR::cpm(adj$normalizedCounts), 
                  col = cols1[x1], ylim = c(-0.5, 0.5),
                  main = paste0("K = ", k, " RLE by batch"))
  EDASeq::plotPCA(edgeR::cpm(adj$normalizedCounts), 
                  col = cols1[x1], labels = FALSE,
                  pch = 19,
                  main = paste0("K = ", k, " PCA by batch"))
  
  x2 <- as.factor(ySub$samples$Group)
  cols2 <- RColorBrewer::brewer.pal(5, "Set1")
  EDASeq::plotPCA(edgeR::cpm(adj$normalizedCounts), 
                  col = cols2[x2], labels = FALSE,
                  pch = 19,
                  main = paste0("K = ", k, " PCA by disease"))
  
  lrt <- glmLRT(fit, contrast = contr[, 1])
  hist(lrt$table$PValue, main = paste0("K = ", k, " ", colnames(contr)[1]),
       cex.main = 0.8)
  lrt <- glmLRT(fit, contrast = contr[, 2])
  hist(lrt$table$PValue, main = paste0("K = ", k, " ", colnames(contr)[2]),
       cex.main = 0.8)
  lrt <- glmLRT(fit, contrast = contr[, 3])
  hist(lrt$table$PValue, main = paste0("K = ", k, " ", colnames(contr)[3]),
       cex.main = 0.8)

}
```


#### Test for DGE using `RUVSeq` and `edgeR`

First, create design matrix to model the sample groups and take into account the unwanted variation, age, sex, severity and replicate samples from the same individual. 

```{r}
# use RUVSeq to identify the factors of unwanted variation
adj <- RUVg(ySub$counts, ctl, k = 5)
W <- adj$W

# create the design matrix
design <- model.matrix(~ 0 + group + W + sex + age)
colnames(design)[1:length(levels(group))] <- levels(group)

# add the factors for the replicate samples
dups <- unique(ySub$samples$Participant[duplicated(ySub$samples$Participant)])
dups <- sapply(dups, function(d){
  ifelse(ySub$samples$Participant == d, 1, 0)  
}, USE.NAMES = TRUE)

design <- cbind(design, dups)
design %>% knitr::kable()
```

Plot expression level of sex genes between males and females for raw and adjusted counts to check that we are not over-adjusting the counts with `RUV`.

```{r}
edgeR::cpm(ySub$counts, log = TRUE) %>% 
      data.frame %>%
      rownames_to_column(var = "gene") %>%
      pivot_longer(-gene, 
                   names_to = "sample", 
                   values_to = "raw") %>%
      inner_join(edgeR::cpm(adj$normalizedCounts, log = TRUE) %>% 
                   data.frame %>%
                   rownames_to_column(var = "gene") %>%
                   pivot_longer(-gene, 
                                names_to = "sample", 
                                values_to = "norm")) %>%
      left_join(rownames_to_column(ySub$samples, 
                                   var = "sample")) %>%
      mutate(Batch = as.factor(Batch)) %>%
      dplyr::filter(gene %in% c("ZFY", "EIF1AY", "XIST")) %>%
      ggplot(aes(x = Sex,
                 y = norm,
                 colour = Sex)) +
      geom_boxplot(outlier.shape = NA, colour = "grey") +
      geom_jitter(stat = "identity",
                  width = 0.15,
                  size = 1.25) +
      geom_jitter(aes(x = Sex,
                      y = raw), stat = "identity",
                  width = 0.15,
                  size = 2, 
                  alpha = 0.2,
                  stroke = 0) +
     ggrepel::geom_text_repel(aes(label = sample.id),
                             size = 2) +
      theme_classic() +
      theme(axis.text.x = element_text(angle = 90,
                                       hjust = 1,
                                       vjust = 0.5),
            legend.position = "bottom",
            legend.direction = "horizontal",
            strip.text = element_text(size = 7),
            axis.text.y = element_text(size = 6)) +
      labs(x = "Group", y = "log2 CPM") +
      facet_wrap(~gene, scales = "free_y") + 
      scale_color_brewer(palette = "Set2") +
      ggtitle("Sex gene expression check") -> p2

p2
```

Create the contrast matrix for the sample group comparisons.

```{r}
contr <- makeContrasts(CF.NO_MODvNON_CF.CTRL = 0.5*(CF.NO_MOD.M + CF.NO_MOD.S) - NON_CF.CTRL,
                       CF.IVAvNON_CF.CTRL = 0.5*(CF.IVA.M + CF.IVA.S) - NON_CF.CTRL,
                       CF.LUMA_IVAvNON_CF.CTRL = 0.5*(CF.LUMA_IVA.M + CF.LUMA_IVA.S) - NON_CF.CTRL,
                       levels = design)

contr %>% knitr::kable()
```

Fit the model.

```{r}
y <- DGEList(counts = ySub$counts)
y <- calcNormFactors(y)
y <- estimateGLMCommonDisp(y, design)
y <- estimateGLMTagwiseDisp(y, design)
fit <- glmFit(y, design)
```


### DEG results

#### Overall summary

```{r}
cutoff <- 0.05

dt <- lapply(1:ncol(contr), function(i){
  decideTests(glmLRT(fit, contrast = contr[,i]),
                           p.value = cutoff)
})

s <- sapply(dt, function(d){
  summary(d)
})
colnames(s) <- colnames(contr)
rownames(s) <- c("Down", "NotSig", "Up")

pal <- c(paletteer::paletteer_d("RColorBrewer::Set1")[2:1], "grey") 

s[-2,] %>% 
  data.frame %>%
  rownames_to_column(var = "Direction") %>%
  pivot_longer(-Direction) %>%
  ggplot(aes(x = name, y = value, fill = Direction)) +
  geom_col(position = "dodge") +
  geom_text(aes(label = value), 
            position = position_dodge(width = 0.9),
            vjust = -0.5,
            size = 3) +
  labs(y = glue("No. DGE (FDR < {cutoff})"),
       x = "Contrast") +
      scale_fill_manual(values = pal) +
  theme(axis.text.x = element_text(angle = 45,
                                   hjust = 1,
                                   vjust = 1)) +
      scale_fill_manual(values = pal)
```
Save the contrast matrix, `edgeR` fit object and `RUVseq` adjusted data as an RDS object for downstream use in plotting, etc.

```{r}
# save LRT results
deg_results <- list(
  contr = contr,
  fit = fit,
  adj = adj)

saveRDS(deg_results, file = here("data",
                                 "intermediate_objects",
                                 glue("{cell}.all_samples.fit.rds")))
```

#### Detailed summary

Explore results of statistical analysis for each contrast with significant DGEs.
First, setup the output directories.

```{r}
outDir <- here("output","dge_analysis")
if(!dir.exists(outDir)) dir.create(outDir)
cellDir <- file.path(outDir, cell)
if(!dir.exists(cellDir)) dir.create(cellDir)
```

Also, perform gene set enrichment analysis (GSEA) using the `cameraPR` method. `cameraPR` tests whether a set of genes is highly ranked relative to other genes in terms of differential expression, accounting for inter-gene correlation. Prepare the Broad MSigDB Gene Ontology, Hallmark gene sets and Reactome pathways.  

```{r}
Hs.c2.all <- convert_gmt_to_list(here("data/c2.all.v2024.1.Hs.entrez.gmt")) 
Hs.h.all <- convert_gmt_to_list(here("data/h.all.v2024.1.Hs.entrez.gmt")) 
Hs.c5.all <- convert_gmt_to_list(here("data/c5.all.v2024.1.Hs.entrez.gmt"))

fibrosis <- create_custom_gene_lists_from_file(here("data/fibrosis_gene_sets.csv"))

# add fibrosis sets from REACTOME and WIKIPATHWAYS
fibrosis <- c(lapply(fibrosis, function(l) l[!is.na(l)]),
              Hs.c2.all[str_detect(names(Hs.c2.all), "FIBROSIS")])

gene_sets_list <- list(HALLMARK = Hs.h.all,
                       GO = Hs.c5.all,
                       REACTOME = Hs.c2.all[str_detect(names(Hs.c2.all), "REACTOME")],
                       WP = Hs.c2.all[str_detect(names(Hs.c2.all), "^WP")],
                       FIBROSIS = fibrosis) 
```

Plot a detailed summary of the results.

```{r, fig.asp=2.6, fig.width=10}
layout <- "
      AAAA
      AAAA
      AAAA
      BBBB
      BBBB
      BBBB
      BBBB
      EEEE
      EEEE
      EEEE
      EEEE"

plot_ruv_results_summary(contr, cutoff, cellDir, gene_sets_list, gns,
                         raw_counts = ySub$counts, 
                         norm_counts = adj$normalizedCounts, 
                         group_info = data.frame(Group = group, 
                                                 sample = rownames(ySub$samples)),
                         layout,
                         pal,
                         severity = rep(FALSE, ncol(contr))) -> p
p
```

#### DEG heatmaps

Heatmaps of up to the top 50 significant DGEs. 

```{r, fig.asp=1}
p <- lapply(1:ncol(contr), function(i){
    lrt <- glmLRT(fit, contrast = contr[,i])
    top <- topTags(lrt, p.value = cutoff, n = Inf) %>% data.frame
    top_deg_heatmap(top = top,
                    comparison = lrt$comparison,
                    counts = adj$normalizedCounts,
                    sample_data = ySub$samples)
})

p
```


## CF modifiers and severity

### Prepare data

#### Filter genes

Extract only the CF samples.

```{r}
ySub <- yFlt[, yFlt$samples$Disease != "Healthy"]
dim(ySub)
```

Filter out genes with no ENTREZ IDs and very low expression.

```{r}
gns <- AnnotationDbi::mapIds(org.Hs.eg.db,
                             keys = rownames(ySub),
                             column = c("ENTREZID"),
                             keytype = "SYMBOL",
                             multiVals = "first")
keep <- !is.na(gns)
ySub <- ySub[keep,]

thresh <- 3
m <- rowMedians(edgeR::cpm(ySub$counts, log = TRUE))
plot(density(m))
abline(v = thresh, lty = 2)
```

```{r}
# filter out genes with low median expression
keep <- m > thresh
table(keep)
ySub <- ySub[keep, ]
dim(ySub)
```

#### Examine covariates

Principal components analysis (PCA) allows us to mathematically determine the sources of variation in the data. We can then investigate whether these correlate with any of the specifed covariates.

Prepare the data.

```{r}
PCs <- prcomp(t(edgeR::cpm(ySub$counts, log = TRUE)), 
              center = TRUE, retx = TRUE)
loadings = PCs$x # pc loadings


nGenes = nrow(ySub)
nSamples = ncol(ySub)

datTraits <- ySub$samples %>% dplyr::select(Batch, Treatment, Micro_code,
                                            Severity, Age, Sex, ncells) %>%
  mutate(Batch = factor(Batch),
         Treatment = factor(Treatment, 
                            labels = 1:length(unique(Treatment))),
         Sex = factor(Sex, labels = length(unique(Sex))),
         Severity = factor(Severity, labels = length(unique(Severity)))) %>%
  mutate(across(everything(), as.numeric))

moduleTraitCor <- suppressWarnings(cor(loadings[, 1:min(10, nSamples)], 
                                       datTraits, use = "p"))
moduleTraitPvalue <- WGCNA::corPvalueStudent(moduleTraitCor, (nSamples-2))

textMatrix <- paste(signif(moduleTraitCor, 2), "\n(", 
                    signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) <- dim(moduleTraitCor)
```

Output results.

```{r, fig.asp=1.3}
par(mfrow = c(2, 1))
plot(PCs, type="lines", main = cell) # scree plot

## Display the correlation values within a heatmap plot
par(cex=0.75, mar = c(3, 5, 2, 1))
WGCNA::labeledHeatmap(Matrix = t(moduleTraitCor),
                            xLabels = colnames(loadings)[1:min(10, nSamples)],
                            yLabels = names(datTraits),
                            colorLabels = FALSE,
                            colors = WGCNA::blueWhiteRed(6),
                            textMatrix = t(textMatrix),
                            setStdMargins = FALSE,
                            cex.text = 1,
                            zlim = c(-1,1),
                            main = paste0("PCA-trait relationships: Top ", 
                                          min(10, nSamples), 
                                          " PCs"))
```

### `RUVseq` analysis

#### Negative control genes

Use house-keeping genes (HKG) identified from human single-cell RNAseq experiments.

```{r}
data("segList", package = "scMerge")

HKGs <- segList$human$bulkRNAseqHK
ctl <- rownames(ySub) %in% HKGs
table(ctl)
```

Plot HKG expression profiles across all the samples.

```{r, fig.asp=1.5, fig.width=10}
edgeR::cpm(ySub$counts, log = TRUE) %>% 
  data.frame %>%
  rownames_to_column(var = "gene") %>%
  pivot_longer(-gene, names_to = "sample") %>%
  left_join(rownames_to_column(ySub$samples, 
                               var = "sample")) %>%
  dplyr::filter(gene %in% HKGs) %>%
mutate(Batch = as.factor(Batch)) -> dat

dat %>%
  heatmap(gene, sample, value,
          scale = "row",
          show_row_names = FALSE,
          show_column_names = FALSE) %>%
  add_tile(Group) %>%
  add_tile(Severity) %>%
  add_tile(Batch) %>%
  add_tile(Participant) %>%
  add_tile(Age) %>%
  add_tile(Sex)
```

MDS plots based only on variablity captured by HKGs.

```{r, fig.asp=1}
mds_by_factor(ySub[rownames(ySub) %in% HKGs,], "as.factor(Batch)", "Batch") & scale_color_brewer(palette = "Set1")
mds_by_factor(ySub[rownames(ySub) %in% HKGs,], "as.factor(Sex)", "Sex") & scale_color_brewer(palette = "Set2")
mds_by_factor(ySub[rownames(ySub) %in% HKGs,], "log2(Age)", "Log2 Age") & scale_colour_viridis_c(option = "magma")
mds_by_factor(ySub[rownames(ySub) %in% HKGs,], "log2(ncells)", "Log2 ncells") & scale_colour_viridis_c(option = "magma")
mds_by_factor(ySub[rownames(ySub) %in% HKGs,], "as.factor(Group)", "Group") & scale_color_brewer(palette = "Dark2")
mds_by_factor(ySub[rownames(ySub) %in% HKGs,], "as.factor(Severity)", "Severity") & 
  scale_color_brewer(palette = "Accent")
mds_by_factor(ySub[rownames(ySub) %in% HKGs,], "as.factor(Micro_code)", "Infection") & scale_color_brewer(palette = "Pastel1")
```

Investigate whether HKG PCAs correlate with any known covariates.
Prepare the data.

```{r}
PCs <- prcomp(t(edgeR::cpm(ySub$counts[ctl, ], log = TRUE)), 
              center = TRUE, retx = TRUE)
loadings = PCs$x # pc loadings


nGenes = nrow(ySub)
nSamples = ncol(ySub)

datTraits <- ySub$samples %>% dplyr::select(Batch, Treatment, 
                                            Severity, Age, Sex, ncells, Micro_code) %>%
  mutate(Batch = factor(Batch),
         Treatment = factor(Treatment, 
                            labels = 1:length(unique(Treatment))),
         Sex = factor(Sex, labels = length(unique(Sex))),
         Severity = factor(Severity, labels = length(unique(Severity)))) %>%
  mutate(across(everything(), as.numeric))

moduleTraitCor <- suppressWarnings(cor(loadings[, 1:min(10, nSamples)], 
                                       datTraits, use = "p"))
moduleTraitPvalue <- WGCNA::corPvalueStudent(moduleTraitCor, (nSamples-2))

textMatrix <- paste(signif(moduleTraitCor, 2), "\n(", 
                    signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) <- dim(moduleTraitCor)
```

Output results.

```{r, fig.asp=1.3}
par(mfrow = c(2, 1))
plot(PCs, type="lines", main = cell) # scree plot

## Display the correlation values within a heatmap plot
par(cex=0.75, mar = c(3, 5, 2, 1))
WGCNA::labeledHeatmap(Matrix = t(moduleTraitCor),
                            xLabels = colnames(loadings)[1:min(10, nSamples)],
                            yLabels = names(datTraits),
                            colorLabels = FALSE,
                            colors = WGCNA::blueWhiteRed(6),
                            textMatrix = t(textMatrix),
                            setStdMargins = FALSE,
                            cex.text = 1,
                            zlim = c(-1,1),
                            main = paste0("PCA-trait relationships: Top ", 
                                          min(10, nSamples), 
                                          " PCs"))
```
#### Select `k` value

First, we need to select `k` for use with `RUVseq`.
Examine the structure of the raw pseudobulk data.

```{r, fig.asp=0.4}
x1 <- as.factor(ySub$samples$Batch)
cols1 <- RColorBrewer::brewer.pal(7, "Set2")

par(mfrow = c(1,3))
EDASeq::plotRLE(edgeR::cpm(ySub$counts),
                col = cols1[x1], ylim = c(-0.5, 0.5),
                main = "Raw RLE by batch", las = 2)
EDASeq::plotPCA(edgeR::cpm(ySub$counts),
                col = cols1[x1], labels = FALSE,
                pch = 19, main = "Raw PCA by batch")
x2 <- as.factor(ySub$samples$Group)
cols2 <- RColorBrewer::brewer.pal(4, "Set1")
EDASeq::plotPCA(edgeR::cpm(ySub$counts),
                col = cols2[x2], labels = FALSE,
                pch = 19, main = "Raw PCA by disease")
```


Select the value for the `k` parameter i.e. the number of columns of the `W` matrix that will be included in the modelling.

```{r, fig.asp=0.8}
# define the sample groups
group <- factor(ySub$samples$Group_severity)
micro <- factor(ySub$samples$Micro_code)
sex <- factor(ySub$samples$Sex)
age <- log2(ySub$samples$Age)

for(k in 1:10){
  adj <- RUVg(ySub$counts, ctl, k = k)
  W <- adj$W

  # create the design matrix
  design <- model.matrix(~0 + group + W + sex + micro + age)
  colnames(design)[1:length(levels(group))] <- levels(group)

  # add the factors for the replicate samples
  dups <- unique(ySub$samples$Participant[duplicated(ySub$samples$Participant)])
  dups <- sapply(dups, function(d){
    ifelse(ySub$samples$Participant == d, 1, 0)
  }, USE.NAMES = TRUE)

  contr <- makeContrasts(CF.IVAvCF.NO_MOD = 0.5*(CF.IVA.S + CF.IVA.M) - 0.5*(CF.NO_MOD.S + CF.NO_MOD.M),
                         CF.LUMA_IVAvCF.NO_MOD = 0.5*(CF.LUMA_IVA.S + CF.LUMA_IVA.M) - 0.5*(CF.NO_MOD.S + CF.NO_MOD.M),
                         CF.NO_MOD.SvCF.NO_MOD.M = CF.NO_MOD.S - CF.NO_MOD.M,
                         levels = design)

  y <- DGEList(counts = ySub$counts)
  y <- calcNormFactors(y)
  y <- estimateGLMCommonDisp(y, design)
  y <- estimateGLMTagwiseDisp(y, design)
  fit <- glmFit(y, design)

  x1 <- as.factor(ySub$samples$Batch)
  cols1 <- RColorBrewer::brewer.pal(7, "Set2")

  par(mfrow = c(2,3))
  EDASeq::plotRLE(edgeR::cpm(adj$normalizedCounts),
                  col = cols1[x1], ylim = c(-0.5, 0.5),
                  main = paste0("K = ", k, " RLE by batch"))
  EDASeq::plotPCA(edgeR::cpm(adj$normalizedCounts),
                  col = cols1[x1], labels = FALSE,
                  pch = 19,
                  main = paste0("K = ", k, " PCA by batch"))

  x2 <- as.factor(ySub$samples$Group)
  cols2 <- RColorBrewer::brewer.pal(5, "Set1")
  EDASeq::plotPCA(edgeR::cpm(adj$normalizedCounts),
                  col = cols2[x2], labels = FALSE,
                  pch = 19,
                  main = paste0("K = ", k, " PCA by disease"))


  lrt <- glmLRT(fit, contrast = contr[, 1])
  hist(lrt$table$PValue, main = paste0("K = ", k, " ", colnames(contr)[1]),
       cex.main = 0.8)
  lrt <- glmLRT(fit, contrast = contr[, 2])
  hist(lrt$table$PValue, main = paste0("K = ", k, " ", colnames(contr)[2]),
       cex.main = 0.8)
  lrt <- glmLRT(fit, contrast = contr[, 3])
  hist(lrt$table$PValue, main = paste0("K = ", k, " ", colnames(contr)[3]),
       cex.main = 0.8)
}
```

#### Test for differences

Test for DGE using `RUVSeq` and `edgeR`. First, create design matrix to model the sample groups and take into account the unwanted variation, age, sex, severity and replicate samples from the same individual. Also include a factor for presence of top 4 clinically important organisms as we are only comparing CF samples which have *all* been tested for the presence of various microorganisms.

```{r}
# use RUVSeq to identify the factors of unwanted variation
adj <- RUVg(ySub$counts, ctl, k = 6)
W <- adj$W

# create the design matrix
design <- model.matrix(~ 0 + group + W + sex + micro + age)
colnames(design)[1:length(levels(group))] <- levels(group)

# add the factors for the replicate samples
dups <- unique(ySub$samples$Participant[duplicated(ySub$samples$Participant)])
dups <- sapply(dups, function(d){
  ifelse(ySub$samples$Participant == d, 1, 0)
}, USE.NAMES = TRUE)

design <- cbind(design, dups)
design %>% knitr::kable()
```


```{r}
edgeR::cpm(ySub$counts, log = TRUE) %>%
      data.frame %>%
      rownames_to_column(var = "gene") %>%
      pivot_longer(-gene,
                   names_to = "sample",
                   values_to = "raw") %>%
      inner_join(edgeR::cpm(adj$normalizedCounts, log = TRUE) %>%
                   data.frame %>%
                   rownames_to_column(var = "gene") %>%
                   pivot_longer(-gene,
                                names_to = "sample",
                                values_to = "norm")) %>%
      left_join(rownames_to_column(ySub$samples,
                                   var = "sample")) %>%
      mutate(Batch = as.factor(Batch)) %>%
      dplyr::filter(gene %in% c("ZFY", "EIF1AY", "XIST")) %>%
      ggplot(aes(x = Sex,
                 y = norm,
                 colour = Sex)) +
      geom_boxplot(outlier.shape = NA, colour = "grey") +
      geom_jitter(stat = "identity",
                  width = 0.15,
                  size = 1.25) +
      geom_jitter(aes(x = Sex,
                      y = raw), stat = "identity",
                  width = 0.15,
                  size = 2,
                  alpha = 0.2,
                  stroke = 0) +
     ggrepel::geom_text_repel(aes(label = sample.id),
                             size = 2) +
      theme_classic() +
      theme(axis.text.x = element_text(angle = 90,
                                       hjust = 1,
                                       vjust = 0.5),
            legend.position = "bottom",
            legend.direction = "horizontal",
            strip.text = element_text(size = 7),
            axis.text.y = element_text(size = 6)) +
      labs(x = "Group", y = "log2 CPM") +
      facet_wrap(~gene, scales = "free_y") +
      scale_color_brewer(palette = "Set2") +
      ggtitle("Sex gene expression check") -> p2

p2
```

Create the contrast matrix for the sample group comparisons.

```{r}
contr <- makeContrasts(
  #CF.IVAvCF.NO_MOD = 0.5*(CF.IVA.S + CF.IVA.M) - 0.5*(CF.NO_MOD.S + CF.NO_MOD.M),
  #                     CF.LUMA_IVAvCF.NO_MOD = 0.5*(CF.LUMA_IVA.S + CF.LUMA_IVA.M) - 0.5*(CF.NO_MOD.S + CF.NO_MOD.M),
                       CF.NO_MOD.SvCF.NO_MOD.M = CF.NO_MOD.S - CF.NO_MOD.M,
                       levels = design)

contr %>% knitr::kable()
```

Fit the model.

```{r}
y <- DGEList(counts = ySub$counts)
y <- calcNormFactors(y)
y <- estimateGLMCommonDisp(y, design)
y <- estimateGLMTagwiseDisp(y, design)
fit <- glmFit(y, design)
```


### DEG results

#### Overall summary

```{r, fig.asp=0.8}
cutoff <- 0.05

dt <- lapply(1:ncol(contr), function(i){
  decideTests(glmLRT(fit, contrast = contr[,i]),
                            p.value = cutoff)
})

s <- sapply(dt, function(d){
  summary(d)
})
colnames(s) <- colnames(contr)
rownames(s) <- c("Down", "NotSig", "Up")

pal <- c(paletteer::paletteer_d("RColorBrewer::Set1")[2:1], "grey")

s[-2,] %>%
  data.frame %>%
  rownames_to_column(var = "Direction") %>%
  pivot_longer(-Direction) %>%
  ggplot(aes(x = name, y = value, fill = Direction)) +
  geom_col(position = "dodge") +
  geom_text(aes(label = value),
            position = position_dodge(width = 0.9),
            vjust = -0.5,
            size = 3) +
  labs(y = glue("No. DGE (FDR < {cutoff})"),
       x = "Contrast") +
      scale_fill_manual(values = pal) +
  theme(axis.text.x = element_text(angle = 45,
                                   hjust = 1,
                                   vjust = 1)) +
      scale_fill_manual(values = pal)
```

Save the contrast matrix, `edgeR` fit object and `RUVseq` adjusted data as an RDS object for downstream use in plotting, etc.

```{r}
# save LRT results
deg_results <- list(
  contr = contr,
  fit = fit,
  adj = adj)

saveRDS(deg_results, file = here("data",
                                 "intermediate_objects",
                                 glue("{cell}.CF_samples.fit.rds")))
```

#### Detailed summary

Explore results of statistical analysis for each contrast with significant DGEs.
First, setup the output directories.

```{r}
outDir <- here("output","dge_analysis")
if(!dir.exists(outDir)) dir.create(outDir)
cellDir <- file.path(outDir, cell)
if(!dir.exists(cellDir)) dir.create(cellDir)
```

Also, perform gene set enrichment analysis (GSEA) using the `cameraPR` method. `cameraPR` tests whether a set of genes is highly ranked relative to other genes in terms of differential expression, accounting for inter-gene correlation. Prepare the Broad MSigDB Gene Ontology, Hallmark gene sets and Reactome pathways.

```{r}
Hs.c2.all <- convert_gmt_to_list(here("data/c2.all.v2024.1.Hs.entrez.gmt"))
Hs.h.all <- convert_gmt_to_list(here("data/h.all.v2024.1.Hs.entrez.gmt"))
Hs.c5.all <- convert_gmt_to_list(here("data/c5.all.v2024.1.Hs.entrez.gmt"))

fibrosis <- create_custom_gene_lists_from_file(here("data/fibrosis_gene_sets.csv"))
# add fibrosis sets from REACTOME and WIKIPATHWAYS
fibrosis <- c(lapply(fibrosis, function(l) l[!is.na(l)]),
              Hs.c2.all[str_detect(names(Hs.c2.all), "FIBROSIS")])

gene_sets_list <- list(HALLMARK = Hs.h.all,
                       GO = Hs.c5.all,
                       REACTOME = Hs.c2.all[str_detect(names(Hs.c2.all), "REACTOME")],
                       WP = Hs.c2.all[str_detect(names(Hs.c2.all), "^WP")],
                       FIBROSIS = fibrosis)
```

Plot a detailed summary of the results.

```{r, fig.asp=2.6, fig.width=10}
layout <- "
      AAAA
      AAAA
      AAAA
      BBBB
      BBBB
      BBBB
      BBBB
      EEEE
      EEEE
      EEEE
      EEEE"

plot_ruv_results_summary(contr, cutoff, cellDir, gene_sets_list, gns,
                         raw_counts = ySub$counts,
                         norm_counts = adj$normalizedCounts,
                         group_info = data.frame(Group = group,
                                                 sample = rownames(ySub$samples)),
                         layout,
                         pal,
                         severity = c(TRUE)) -> p
p
```

#### DEG heatmaps

Heatmaps of up to the top 50 significant DGEs. 

```{r, fig.asp=1}
p <- lapply(1:ncol(contr), function(i){
    lrt <- glmLRT(fit, contrast = contr[,i])
    top <- topTags(lrt, p.value = cutoff, n = Inf) %>% data.frame
    top_deg_heatmap(top = top,
                    comparison = lrt$comparison,
                    counts = adj$normalizedCounts,
                    sample_data = ySub$samples)
})

p
```

# Session info {.appendix}

